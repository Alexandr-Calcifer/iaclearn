# Изучение 11 главы книги.

## Вопросы:
### 1. Что для программы является исключительной ситуацией? Какие существуют способы обработки ошибок в программах?
Исключительная ситуация (Exception) в программе представляет собой событие, которое нарушает нормальное выполнение 
программы и может быть вызвано ошибками, неожиданными условиями или непредсказуемыми событиями. Исключительные ситуации 
могут возникать из-за ошибок ввода-вывода, некорректных данных, недоступности ресурсов, ошибок в вычислениях и других 
непредвиденных событий.

Существует несколько способов обработки ошибок в программах:

1. `Обработка исключений с использованием блоков try-catch`: Механизм try-catch позволяет перехватывать и обрабатывать 
исключительные ситуации. Код, который может вызывать исключение, помещается в блок try, а обработка исключения 
выполняется в блоках catch. В блоке catch можно предусмотреть специфическую обработку исключения, вывод сообщения об 
ошибке или выполнение альтернативных действий.
2. `Использование блока finally`: Блок finally может быть добавлен после блока catch и содержит код, который будет 
выполнен независимо от того, произошло исключение или нет. Это полезно, например, для освобождения ресурсов, закрытия 
открытых файлов или соединений.
3. `Генерация исключений`: В программе вы также можете сгенерировать исключение самостоятельно с помощью ключевого слова 
throw. Это полезно, когда вы хотите указать на возникновение ошибочной ситуации или передать управление обработчику 
исключений на более высоком уровне.
4. `Использование иерархии исключений`: В Java существует иерархия исключений, начиная от базового класса Throwable. Вы 
можете выбирать подходящий класс исключений из этой иерархии или создавать свои собственные классы исключений, чтобы 
лучше отражать характер ошибки и упростить ее обработку.
5. `Обработка неотслеженных исключений`: Некоторые исключения, называемые неотслеживаемыми исключениями (Unchecked 
Exceptions), могут не требовать явного объявления в сигнатуре метода или обработки в блоке try-catch. Это включает в 
себя RuntimeException и его подклассы. Обычно, для таких исключений используется обработка на верхнем уровне или их 
предотвращение с помощью правильного проектирования кода и контроля входных данных.

Обработка ошибок в программах помогает предотвратить нежелательное завершение программы, предоставляет информацию об 
ошибке и позволяет выполнить соответствующие действия для восстановления или обработки ошибки. Это помогает создавать 
более надежные и устойчивые программы.

### 2. Что такое исключение для Java-программы? Что значит «программа генерировала\выбросила исключение»? Привести пример, когда исключения генерируются виртуальной машиной (автоматически) и когда необходимо их генерировать вручную.
Исключение (Exception) в Java - это объект, который представляет собой необычную или неожиданную ситуацию, возникающую 
во время выполнения программы. Исключения используются для обработки ошибок и других исключительных ситуаций, которые 
могут возникнуть в программе.

Когда говорят, что программа "генерировала" или "выбросила" исключение, это означает, что произошло исключительное 
событие или ошибка, и JVM (виртуальная машина Java) создает объект-исключение и передает его обработчику исключений для 
соответствующей обработки. Возникновение исключения приводит к прерыванию нормального потока выполнения программы и 
переходу к коду обработки исключения.

Примеры автоматической генерации исключений виртуальной машиной:

1. `NullPointerException`: Возникает, когда код пытается обратиться к объекту, который имеет значение `null`.
2. `ArrayIndexOutOfBoundsException`: Возникает, когда индекс массива находится вне диапазона допустимых индексов.
3. `ArithmeticException`: Возникает, когда происходит ошибка в арифметической операции, например, деление на ноль.

Следует заметить, что виртуальная машина автоматически генерирует исключения в этих случаях на основе правил исключений,
определенных в языке Java.

В некоторых случаях вам может потребоваться генерировать исключения вручную. Это может быть полезно, когда вы 
сталкиваетесь с определенными ситуациями или ошибками, которые не обрабатываются автоматически. Некоторые примеры 
ситуаций, когда необходимо генерировать исключения вручную:

1. `Проверка некорректных входных данных`: Если входные данные не соответствуют ожидаемым значениям или условиям, можно 
сгенерировать исключение для указания на ошибочную ситуацию.
2. `Неожиданные условия`: Если ваш код сталкивается с неожиданными условиями, которые не могут быть автоматически 
обработаны, можно выбросить исключение для указания на такую ситуацию.
3. `Ошибки валидации`: При валидации данных или проверке предусловий можно сгенерировать исключение, чтобы указать на ошибку.

Пример генерации исключения вручную:
```java
public int divide(int dividend, int divisor) throws ArithmeticException {
    if (divisor == 0) {
        throw new ArithmeticException("Деление на ноль недопустимо");
    }
    return dividend / divisor;
}
```

В этом примере, если значение делителя равно нулю, мы явно генерируем исключение ArithmeticException с сообщением об 
ошибке. Это позволяет явно указать на ошибку деления на ноль и передать информацию об ошибке обработчику исключений.

### 3. Привести иерархию классов-исключений, делящую исключения на проверяемые и непроверяемые. В чем особенности проверяемых и непроверяемых исключений?
Иерархия классов-исключений в Java делит исключения на две основные категории: проверяемые и непроверяемые исключения. 
Это определяется отношением исключений к классам Exception и RuntimeException соответственно.

1. `Проверяемые исключения (Checked Exceptions)`:
   - Наследуются от класса `Exception`, но не наследуются от класса `RuntimeException`.
   - Компилятор Java требует явного обработчика для проверяемых исключений или объявления их в сигнатуре метода с 
   использованием ключевого слова `throws`.
   - Примеры проверяемых исключений: `IOException`, `SQLException`, `FileNotFoundException`.
   - Обычно они представляют ошибки, связанные с вводом-выводом, работой с файлами, сетью и другими внешними ресурсами.
   - Обработка проверяемых исключений обычно требует принятия решений и восстановления состояния программы.
2. `Непроверяемые исключения (Unchecked Exceptions)`:
   - Наследуются от класса `RuntimeException` (который seiner наследуется от класса `Exception`) или его подклассов.
   - Непроверяемые исключения не требуют явного объявления в сигнатуре метода или обработчика исключений.
   - Примеры непроверяемых исключений: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`.
   - Обычно они указывают на ошибки программиста или непредвиденные ситуации во время выполнения, которые не могут быть 
   обработаны на уровне кода и требуют исправления или более тщательного тестирования.

Основные особенности проверяемых и непроверяемых исключений:

- Обработка: Проверяемые исключения требуют обработки на уровне кода, что позволяет программисту принимать решение о 
том, как восстановиться после исключительной ситуации. Непроверяемые исключения не требуют явной обработки и обычно 
указывают на фатальные ошибки или проблемы в коде, требующие исправления.
- Контроль компилятора: Проверяемые исключения подчиняются контролю компилятора, который требует их явной обработки или 
объявления в сигнатуре метода с использованием throws. Непроверяемые исключения не контролируются компилятором и могут 
быть обработаны по усмотрению программиста.
- Последствия: Проверяемые исключения обычно вызывают остановку текущей операции и требуют принятия мер для 
восстановления или корректного завершения программы. Непроверяемые исключения указывают на ошибки, которые не могут быть
обработаны на текущем уровне, и часто приводят к аварийному завершению программы.

Правильное обращение с проверяемыми и непроверяемыми исключениями помогает создавать надежные и устойчивые программы. 
Проверяемые исключения обеспечивают контроль над исключительными ситуациями, которые могут возникнуть во время 
выполнения программы, в то время как непроверяемые исключения обычно указывают на проблемы в коде или другие 
фатальные ошибки.

### 4. Объяснить работу оператора try-catch-finally. Когда данный оператор следует использовать? Сколько блоков catch может соответствовать одному блоку try?
Оператор try-catch-finally используется для обработки исключений в Java. Он позволяет обернуть блок кода, в котором 
может произойти исключение, в блок try, а затем предоставляет возможность перехватить и обработать это исключение в одном
или нескольких блоках catch. Блок finally, если присутствует, выполняется в любом случае, независимо от того, произошло 
исключение или нет.

Работа оператора try-catch-finally осуществляется следующим образом:

1. Код, который может вызвать исключение, помещается в блок try.
2. Если в блоке try происходит исключение, оно считается "брошенным" (thrown), и выполнение кода внутри блока try 
прекращается.
3. Система Java проверяет, соответствует ли тип выброшенного исключения одному из блоков catch, расположенных ниже блока
try. Если соответствие найдено, управление передается в соответствующий блок catch, где выполняется обработка исключения.
4. Если исключение не соответствует ни одному блоку catch, оно "перебрасывается" (re-thrown) во внешний обработчик или 
прекращает выполнение программы.
5. Если в блоке try исключение не произошло или было обработано, блок finally (если присутствует) выполняется после 
блока try-catch. Блок finally используется для освобождения ресурсов или выполнения завершающих операций, независимо от 
того, произошло исключение или нет.

Оператор try-catch-finally следует использовать в случаях, когда вы ожидаете возникновение исключительных ситуаций, 
которые могут повлиять на нормальное выполнение программы, и вы хотите обработать их или выполнить определенные действия
в случае возникновения ошибки. Это может включать чтение и запись файлов, работу с сетью, взаимодействие с базой данных 
и другие операции, которые могут привести к исключительным ситуациям.

Блок try может иметь один или несколько блоков catch, которые следуют непосредственно за ним. Блоки catch предназначены 
для обработки различных типов исключений. Один блок catch может соответствовать одному типу исключения. Если требуется 
обработка нескольких типов исключений, можно использовать несколько блоков catch, каждый из которых обрабатывает свой 
тип исключения.

Пример использования оператора try-catch-finally:

```java
try {
    // Код, который может вызвать исключение
    // ...
} catch (ExceptionType1 e1) {
    // Обработка исключения типа ExceptionType1
    // ...
} catch (ExceptionType2 e2) {
    // Обработка исключения типа ExceptionType2
    // ...
} finally {
    // Код, который выполняется независимо от возникновения исключения
    // ...
}
```

В этом примере блок try содержит код, который может вызвать исключение. Если исключение соответствует типу 
ExceptionType1, оно будет перехвачено и обработано в первом блоке catch. Если исключение соответствует типу 
ExceptionType2, оно будет перехвачено и обработано во втором блоке catch. Блок finally будет выполняться независимо от 
того, произошло исключение или нет.

### 5. Можно ли вкладывать блоки try друг в друга, можно ли вложить блок try в catch или finally? Как происходит обработка исключений, выброшенных внутренним блоком try, если среди его блоков catch нет подходящего?
Да, блоки try могут быть вложены друг в друга в Java. Вложенные блоки try позволяют более точно управлять обработкой 
исключений в зависимости от контекста выполнения кода.

Пример вложенных блоков try:

```java
try {
    // Внешний блок try
    try {
        // Внутренний блок try
        // ...
    } catch (ExceptionType1 e1) {
        // Обработка исключения типа ExceptionType1 во внутреннем блоке catch
        // ...
    } finally {
        // Код во внутреннем блоке finally
        // ...
    }
} catch (ExceptionType2 e2) {
    // Обработка исключения типа ExceptionType2 во внешнем блоке catch
    // ...
} finally {
    // Код во внешнем блоке finally
    // ...
}
```

В этом примере внутренний блок try находится внутри внешнего блока try. При выполнении кода, если внутренний блок try
вызывает исключение, оно будет перехвачено внутренним блоком catch и обработано соответствующим образом. Затем 
выполнение кода продолжится внутри внешнего блока try или будет перенаправлено во внешний блок catch, если внутренний 
блок try не содержит соответствующего блока catch.

Вложение блока try в блок catch или finally не разрешено в языке Java. Внутренний блок try должен находиться внутри
внешнего блока try.

Если исключение выбрасывается во внутреннем блоке try, и ни один из его блоков catch не соответствует типу выброшенного 
исключения, оно будет перенаправлено на уровень выше, во внешний блок try (если есть) или к следующему блоку catch в 
стеке вызовов. Этот процесс продолжается до тех пор, пока не будет найден подходящий блок catch или исключение не 
достигнет верхнего уровня программы. Если исключение доходит до верхнего уровня программы и не обрабатывается, оно может
привести к прерыванию выполнения программы и выводу трассировки стека (stack trace) с информацией об исключении.

Важно помнить, что обработка исключений должна быть организована таким образом, чтобы исключения могли быть обработаны в
подходящем месте и приняты соответствующие меры для восстановления или завершения программы без нежелательных побочных 
эффектов.

### 6. Что называют стеком операторов try? Как работает блок try с ресурсами?
Стек операторов try (try-with-resources stack) - это механизм, введенный в Java 7, который позволяет удобно и безопасно работать с ресурсами, которые должны быть закрыты после использования. Стек операторов try обеспечивает автоматическое закрытие ресурсов независимо от того, произошло исключение или нет.

Работа блока try с ресурсами состоит из следующих этапов:

1. В круглых скобках после оператора try указываются один или несколько ресурсов, которые требуется использовать. 
Ресурсы должны реализовывать интерфейс `AutoCloseable` или `Closeable`.
2. За блоком try с ресурсами следует блок кода, в котором ресурсы могут быть использованы.
3. По завершении блока try с ресурсами или при возникновении исключения происходит автоматическое закрытие ресурсов.
4. Ресурсы закрываются в порядке, обратном их открытию, то есть в порядке, обратном порядку их появления в блоке try с 
ресурсами.

Пример использования блока try с ресурсами:

```java
try (Resource resource1 = new Resource1(); Resource resource2 = new Resource2()) {
    // Использование ресурсов
    // ...
} catch (Exception e) {
    // Обработка исключений
    // ...
}
```

В этом примере `Resource1` и `Resource2` - это ресурсы, которые реализуют интерфейс `AutoCloseable` или `Closeable`. 
Когда блок кода внутри блока try с ресурсами завершается, ресурсы автоматически закрываются в порядке, обратном их 
открытию. Если при использовании ресурсов происходит исключение, оно перехватывается и обрабатывается в блоке catch, а 
затем ресурсы все равно автоматически закрываются.

Основные преимущества блока try с ресурсами:

1. `Автоматическое закрытие ресурсов`: Блок try с ресурсами обеспечивает автоматическое закрытие ресурсов, что устраняет 
необходимость в явном вызове метода `close()` или использовании блока finally для освобождения ресурсов.
2. `Безопасное использование ресурсов`: Даже если происходит исключение при использовании ресурсов, блок try с ресурсами 
гарантирует, что ресурсы будут закрыты без необходимости обрабатывать исключения вручную.
3. `Улучшенная читаемость кода`: Блок try с ресурсами делает код более компактным и улучшает его читаемость, так как 
закрытие ресурсов происходит непосредственно в том же месте, где они были открыты.

При использовании блока try с ресурсами важно убедиться, что ресурсы, которые требуется закрыть, реализуют интерфейс 
`AutoCloseable` или `Closeable` и что они были правильно реализованы для освобождения ресурсов в методе `close()`.
Это гарантирует, что ресурсы будут закрыты надлежащим образом после использования, даже в случае возникновения исключения.

### 7. Указать правило расположения блоков catch в зависимости от типов перехватываемых исключений. Может ли перехваченное исключение быть сгенерировано снова, и, если да, то как и кто в этом случае будет обрабатывать повторно сгенерированное исключение? Может ли блок catch выбрасывать иные исключения, и если да, то привести пример, когда это может быть необходимо.
Правила расположения блоков catch в операторе try-catch в Java следующие:

1. Блоки catch должны быть расположены в порядке от наиболее конкретных типов исключений к более общим типам исключений.
2. Блок catch для более общего типа исключения не может предшествовать блоку catch для его подтипа. Это нарушает логику 
обработки исключений, поскольку все исключения этого типа будут перехватываться более общим блоком catch.

Пример правильного расположения блоков catch:

```java
try {
    // Код, который может вызвать исключение
    // ...
} catch (SpecificException e) {
    // Обработка конкретного типа исключения SpecificException
    // ...
} catch (GeneralException e) {
    // Обработка более общего типа исключения GeneralException
    // ...
} catch (Exception e) {
    // Обработка наиболее общего типа исключения Exception
    // ...
}
```

В этом примере блок catch для типа `SpecificException` находится перед блоком catch для его более общего типа 
`GeneralException`. Это соответствует правилу расположения блоков catch от конкретного к общему.

Перехваченное исключение может быть сгенерировано снова (re-thrown), чтобы передать его обработку на более высокий 
уровень. Для этого можно использовать оператор throw без указания конкретного исключения. Повторно сгенерированное 
исключение будет обрабатываться на верхнем уровне во внешнем блоке try-catch или будет передано следующему блоку catch 
в стеке вызовов.

Пример повторного генерирования исключения:

```java
try {
    // Код, который может вызвать исключение
    // ...
} catch (Exception e) {
    // Обработка исключения
    // Повторное генерирование исключения
    throw e;
}
```

В этом примере исключение, которое было перехвачено в блоке catch, снова выбрасывается с использованием оператора throw.
Это передает исключение на более высокий уровень обработки или другому блоку catch, который может обработать это исключение.

Блок catch также может выбрасывать иные исключения, помимо перехваченного исключения. Это может быть необходимо, когда 
требуется передать информацию об ошибке или сгенерировать новое исключение, чтобы указать на другую проблему.

Пример выбрасывания другого исключения в блоке catch:

```java
try {
    // Код, который может вызвать исключение
    // ...
} catch (Exception e) {
    // Обработка исключения
    // Генерирование другого исключения
    throw new CustomException("Custom error message");
}
```

В этом примере блок catch выбрасывает новое исключение типа `CustomException` с указанным пользовательским сообщением об
ошибке. Это может быть полезно для предоставления более конкретной информации об ошибке или для указания на другую 
проблему, которую не удалось обработать в блоке catch.

### 8. Когда происходит вызов блока finally? Существуют ли ситуации, когда блок finally не будет вызван? Может ли блок finally выбрасывать исключения? Может ли блок finally выполниться дважды?
Блок `finally` в операторе `try-catch-finally` вызывается всегда, независимо от того, произошло исключение или нет. Он 
выполняется после выполнения блока `try` и любых соответствующих блоков `catch`, независимо от того, было ли выброшено 
исключение или оно было перехвачено.

Однако есть несколько ситуаций, когда блок `finally` может не быть вызван:

1. `Преждевременное завершение программы`: Если происходит аварийное завершение программы, например, из-за вызова 
метода `System.exit()` или необрабатываемого исключения верхнего уровня, блок `finally` не будет выполнен.
2. `Систематическая ошибка`: Если во время выполнения программы происходит систематическая ошибка, такая как сбой JVM 
или неконтролируемое состояние системы, блок `finally` может не быть вызван.

Блок `finally` не может выбрасывать исключения. Если в блоке `finally` возникает исключение, оно может быть перехвачено 
во внешнем блоке `catch`, но исходное исключение, которое возникло внутри блока `try` или `catch`, будет затерто. Это 
может привести к потере информации об исключении и искажению диагностики ошибки.

Блок `finally` не будет выполнен дважды в стандартной ситуации. Он будет выполнен только один раз после завершения 
выполнения блока `try` и всех соответствующих блоков `catch`. Однако есть некоторые исключения, когда блок `finally` 
может быть выполнен дважды:

1. Вызов return в блоке `finally`: Если блок `finally` содержит оператор `return`, то после выполнения этого оператора 
блок `finally` выполнится во второй раз, когда управление вернется из метода.
2. Вызов `System.exit()` в блоке `finally`: Если блок `finally` вызывает `System.exit()`, происходит аварийное 
завершение программы и блок `finally` не будет выполнен во второй раз.

Обычно блок `finally` используется для освобождения ресурсов, закрытия файлов, соединений с базами данных и других
завершающих операций, которые требуются независимо от того, произошло исключение или нет.

### 9. Как генерировать исключение вручную? Объекты каких классов могут быть генерированы в качестве исключений? Можно ли генерировать два исключения одновременно?
Для генерации исключения вручную в Java используется оператор `throw`. Оператор `throw` позволяет выбросить исключение, 
созданное в коде программы, чтобы указать на ошибочное состояние или неожиданную ситуацию.

Синтаксис оператора throw выглядит следующим образом:

```java
throw exceptionObject;
```

Где `exceptionObject` - объект, который является экземпляром класса, производного от класса `Throwable` (или сам класс 
`Throwable`). Классы-исключения должны быть определены и их объекты могут быть сгенерированы в качестве исключений.

В Java существуют два основных типа классов-исключений:

1. `Checked Exceptions (проверяемые исключения)`: Это исключения, которые должны быть объявлены в сигнатуре метода или 
обработаны в блоке `try-catch`. Они наследуются от класса `Exception`, но не от класса `RuntimeException`. Примеры: 
`IOException`, `SQLException`.
2. `Unchecked Exceptions (непроверяемые исключения)`: Это исключения, которые не требуют объявления в сигнатуре метода 
или обработки в блоке `try-catch`. Они наследуются от класса `RuntimeException` или его подклассов. Примеры: 
`NullPointerException`, `ArrayIndexOutOfBoundsException`.

Вы можете генерировать только одно исключение в одном операторе `throw`. Однако, если вы хотите выбросить несколько 
исключений одновременно, вы можете создать объект, который будет содержать информацию о нескольких исключениях, и затем 
выбросить этот объект как единое исключение. Например, вы можете создать свой собственный класс-исключение, который 
содержит внутри себя несколько исключений в виде списка или массива.

Пример генерации исключения вручную:

```java
public void processValue(int value) {
    if (value < 0) {
        throw new IllegalArgumentException("Value cannot be negative");
    }
    // остальной код
}
```

В этом примере, если значение `value` является отрицательным, генерируется исключение `IllegalArgumentException` с 
соответствующим сообщением об ошибке.

### 10. Объяснить, как работают операторы throw и throws. В чем их отличия? 
Операторы throw и throws используются для работы с исключениями в Java, но имеют разные цели и функциональность:

1. Оператор `throw`:
    - Оператор `throw` используется для явной генерации исключения внутри кода программы.
    - С помощью оператора `throw` можно выбросить исключение вручную, указав объект-исключение, который будет 
   представлять ошибочное состояние или неожиданную ситуацию.
    - Оператор `throw` следует использовать внутри блока `try` или метода, чтобы указать, что произошла ошибка или 
   исключительная ситуация и необходимо прервать нормальное выполнение кода.
    - Оператор `throw` используется с объектами-исключениями, которые являются экземплярами классов, производных от 
   класса `Throwable` или самого класса `Throwable`.
2. Оператор `throws`:
    - Оператор `throws` используется в объявлении метода для указания, какие исключения могут быть выброшены из этого 
   метода.
    - Оператор `throws` указывает, что метод может вызывать исключение указанного типа и что вызывающий код должен 
   обрабатывать или передавать это исключение.
    - Оператор `throws` следует использовать в сигнатуре метода, после имени метода и перед открывающей фигурной 
   скобкой. Он перечисляет типы исключений, которые может выбросить метод, разделенные запятой.
    - Оператор `throws` используется для указания исключений, которые метод может сгенерировать, но он сам не 
   обрабатывает их внутри. Это переносит ответственность за обработку исключений вызывающему коду.

Отличия между операторами throw и throws:

- `throw` используется внутри кода для выброса конкретного исключения.
- `throws` используется в сигнатуре метода для указания, какие исключения метод может выбросить.
- `throw` генерирует исключение и может быть использован внутри блока `try` для явной обработки ошибок.
- `throws` объявляет, что метод может вызывать исключения указанных типов, и это объявление требует обработки или 
передачи исключений вызывающим кодом.

Пример использования оператора `throw`:

```java
public void processValue(int value) {
    if (value < 0) {
        throw new IllegalArgumentException("Value cannot be negative");
    }
    // остальной код
}
```

Пример использования оператора `throws`:

```java
public void readFile(String filename) throws FileNotFoundException, IOException {
    // Код для чтения файла
    // ...
}
```

```java
public void readFile(String filename) throws FileNotFoundException, IOException {
    // Код для чтения файла
    // ...
}
```

В этом примере метод `readFile` объявляет, что он может вызывать исключения `FileNotFoundException` и `IOException` при 
чтении файла. Вызывающий код должен обрабатывать или передавать эти исключения.

### 11. Объяснить правила реализации секции throws при переопределении метода и при описании конструкторов производного класса.
При переопределении метода и описании конструкторов производного класса в Java секция `throws` имеет следующие правила:

Переопределение метода:
- При переопределении метода в подклассе можно использовать более узкие типы исключений в секции `throws`.
- Если базовый метод объявляет исключение в своей секции `throws`, то переопределяющий метод может выбрасывать только 
исключения из того же типа или его подтипы. Более широкие типы исключений не разрешены.
- Если базовый метод не объявляет исключения (не имеет секции `throws`), то переопределяющий метод также не может 
объявлять исключения. Он может выбрасывать только непроверяемые исключения.

Пример переопределения метода с секцией `throws`:

```java
class Parent {
    public void method() throws IOException {
        // Базовый метод объявляет IOException
        // ...
    }
}

class Child extends Parent {
    @Override
    public void method() throws FileNotFoundException {
        // Переопределяющий метод объявляет FileNotFoundException
        // ...
    }
}
```

В этом примере базовый метод `method` в классе `Parent` объявляет `IOException` в своей секции `throws`, а 
переопределяющий метод в классе `Child` может выбрасывать только подтип `FileNotFoundException` этого исключения.

Описание конструкторов производного класса:
- При описании конструкторов в производном классе секция `throws` должна быть совместима с секцией `throws` 
конструкторов базового класса.
- Если базовый класс объявляет исключения в секции `throws` своих конструкторов, то производный класс должен либо не 
выбрасывать исключения, либо выбрасывать те же самые исключения или их подтипы.
- Если базовый класс не объявляет исключения в секции `throws` своих конструкторов, то производный класс также не 
должен объявлять исключения в своих конструкторах.

### 12. Как ведет себя блок throws при работе с проверяемыми и непроверяемыми исключениями?
Блок `throws` используется для указания списка проверяемых исключений, которые метод может генерировать. При работе с 
проверяемыми и непроверяемыми исключениями, блок `throws` ведет себя следующим образом:

1. `Проверяемые исключения`:
   - Если метод объявляет проверяемое исключение в секции `throws`, то вызывающий код должен обрабатывать это исключение
   с помощью блока `try-catch` или также указать его в своей секции `throws`.
   - Если проверяемое исключение не обработано в методе или не указано в его секции `throws`, компилятор Java выдаст 
   ошибку компиляции.
   - Проверяемые исключения обычно являются исключениями, которые наследуются от класса `Exception`, но не от класса 
   `RuntimeException`.
2. `Непроверяемые исключения`:
   - Непроверяемые исключения, также известные как временные исключения или исключения времени выполнения, не требуют 
   обработки или объявления в секции `throws`.
   - Непроверяемые исключения обычно являются исключениями, которые наследуются от класса `RuntimeException` или его 
   подклассов.
   - Вызывающий код может выбрать обработку или необработку непроверяемых исключений в зависимости от своих потребностей.

Пример использования блока throws с проверяемым и непроверяемым исключениями:

```java
public void method() throws IOException, NullPointerException {
    // Метод может генерировать IOException (проверяемое исключение)
    // и NullPointerException (непроверяемое исключение)
    // ...
}
```

В этом примере метод method объявляет, что он может генерировать проверяемое исключение `IOException` и непроверяемое 
исключение `NullPointerException`. Если вызывающий код хочет использовать этот метод, он должен либо обрабатывать эти 
исключения с помощью блока `try-catch`, либо также указывать их в своей секции `throws`.

Исключения, наследуемые от класса `RuntimeException`, такие как `NullPointerException` и `IllegalArgumentException`, не 
требуют обработки или объявления в секции `throws`, поэтому код, который вызывает метод, может обрабатывать или 
игнорировать их по своему усмотрению.

### 13. Каков будет результат создания объекта, если конструктор при работе сгенерирует исключительную ситуацию?
Если конструктор при работе сгенерирует исключительную ситуацию (исключение), создание объекта не будет завершено и 
исключение будет выброшено из конструктора. Создание объекта не произойдет, и переменная, которой предназначался 
созданный объект, останется без инициализации.

При вызове конструктора, если внутри него происходит исключение, выполнение конструктора немедленно прекращается, и 
исключение передается вызывающему коду. Это означает, что создание объекта не будет завершено.

В зависимости от типа исключения, возможны различные действия при генерации исключения в конструкторе:

`Проверяемые исключения`:
- Если конструктор генерирует проверяемое исключение (наследуется от класса `Exception`, но не от `RuntimeException`), 
то вызывающий код должен обрабатывать исключение с помощью блока `try-catch` или также указать исключение в своей секции 
`throws`. Если вызывающий код не обрабатывает или не указывает исключение, будет сгенерирована ошибка компиляции.

`Непроверяемые исключения`:
- Если конструктор генерирует непроверяемое исключение (наследуется от класса `RuntimeException` или его подклассов), 
то вызывающий код может выбрать обработку или игнорирование исключения, так как непроверяемые исключения не требуют 
обработки или объявления в секции `throws`.

Пример генерации исключения в конструкторе:

```java
public class MyClass {
    public MyClass() {
        if (someCondition) {
            throw new RuntimeException("Some error occurred");
        }
        // остальной код конструктора
    }
}
```

В этом примере, если `someCondition` истинно, то конструктор `MyClass` генерирует исключение `RuntimeException`. Создание
объекта класса `MyClass` не будет завершено, и исключение будет передано вызывающему коду для обработки или игнорирования.

### 14. Нужно ли генерировать исключения, входящие в Java SE? Как создать собственные классы исключений?
В Java SE уже предоставлено множество классов исключений, которые покрывают широкий спектр возможных ошибок и 
исключительных ситуаций. Поэтому в большинстве случаев нет необходимости создавать новые исключения для ошибок, которые 
могут быть описаны с использованием существующих классов исключений из стандартной библиотеки Java.

Однако иногда возникает необходимость создать собственные классы исключений, когда стандартные исключения не отражают 
достаточно точно или не позволяют передать специфическую информацию об ошибке. Создание собственных классов исключений 
позволяет более точно описать ошибку и предоставить дополнительные данные для ее обработки.

Для создания собственного класса исключения в Java необходимо создать новый класс, который наследуется от класса 
`Exception` (для проверяемых исключений) или `RuntimeException` (для непроверяемых исключений). Новый класс исключения 
может содержать дополнительные поля, методы и конструкторы, чтобы предоставить дополнительную информацию об ошибке.

Пример создания собственного класса исключения:

```java
public class CustomException extends Exception {
    private int errorCode;

    public CustomException(String message, int errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public int getErrorCode() {
        return errorCode;
    }
}
```

В этом примере создается класс `CustomException`, который наследуется от класса `Exception`. Класс `CustomException` 
имеет дополнительное поле `errorCode` и метод `getErrorCode()`, чтобы предоставить информацию об ошибке. Конструктор 
класса `CustomException` принимает сообщение и код ошибки и передает сообщение в конструктор класса `Exception` с 
помощью ключевого слова `super`.

Созданный класс исключения может быть выброшен в коде программы с использованием оператора `throw`, и вызывающий код 
может обрабатывать этот класс исключения или передавать его выше по стеку вызовов.

```java
public void someMethod() throws CustomException {
    if (someCondition) {
        throw new CustomException("Some error occurred", 100);
    }
    // остальной код метода
}
```

В этом примере метод `someMethod()` может генерировать исключение `CustomException`, передавая сообщение об ошибке и 
код ошибки. Вызывающий код может обработать это исключение с помощью блока `try-catch` или также указать его в своей 
секции `throws`.