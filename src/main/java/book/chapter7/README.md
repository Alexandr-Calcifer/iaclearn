# Изучение 7 главы книги.

## Вопросы:
### 1. Дать определение функционального интерфейса. default & static методы. Область применения. Каким образом вызываются?

Функциональный интерфейс в Java - это интерфейс, который содержит только один абстрактный метод. Он предназначен для 
использования с лямбда-выражениями или методами ссылок. Функциональные интерфейсы позволяют вам передавать поведение в 
виде аргументов методов или хранить их в переменных.

Default-методы были введены в Java 8 для предоставления реализации по умолчанию в интерфейсах. Они позволяют добавлять 
новые методы в интерфейсы, не нарушая существующие реализации. Классы, реализующие интерфейс, могут использовать или 
переопределить default-методы.

Static-методы в интерфейсах также были добавлены в Java 8. Они могут иметь только реализацию по умолчанию и не могут 
быть переопределены в классах, реализующих интерфейс. Static-методы используются для предоставления утилитарных методов,
которые могут быть вызваны независимо от конкретной реализации интерфейса.

Область применения функциональных интерфейсов, default-методов и static-методов в Java заключается в облегчении 
разработки кода с использованием интерфейсов. Они позволяют создавать более гибкие и расширяемые интерфейсы, добавлять 
новую функциональность в существующие интерфейсы без нарушения обратной совместимости, а также упрощать работу с 
лямбда-выражениями.

Для вызова default-методов и static-методов интерфейсов используются следующие способы:
* Вызов default-метода: Если у вас есть экземпляр класса, реализующего интерфейс, вы можете вызвать default-метод,
используя этот экземпляр:

`InterfaceName.super.defaultMethodName();`
* Вызов static-метода: Вызов static-метода осуществляется непосредственно через имя интерфейса:

`InterfaceName.staticMethodName();`

###  2. Что такое лямбда-выражение? Его структура.

Лямбда-выражение в Java - это компактный способ представления анонимной функции (функции без имени) и его основной 
целью является передача поведения в качестве аргумента метода или хранение его в переменной. Лямбда-выражения в Java 
впервые были введены в версии 8 и являются частью функционального программирования в Java.
Структура лямбда-выражения состоит из трех основных компонентов:

* Список параметров: Это список входных параметров, передаваемых в анонимную функцию. Если у лямбда-выражения нет 
параметров, вы указываете пустые скобки "()". Если у лямбда-выражения есть один параметр, скобки могут быть опущены.
Если у лямбда-выражения есть несколько параметров, они перечисляются через запятую в скобках.

* Оператор "стрелка" ("->"): Это оператор, который разделяет список параметров и тело лямбда-выражения. Оператор
"стрелка" состоит из дефиса и знака больше "->".

* Тело лямбда-выражения: Это блок кода, который выполняется при вызове лямбда-выражения. Тело может быть одним 
выражением или блоком кода, заключенным в фигурные скобки "{}". Если тело состоит из одного выражения, фигурные 
скобки и ключевое слово "return" могут быть опущены.

Вот примеры различных структур лямбда-выражений:

* Лямбда-выражение без параметров:

`() -> System.out.println("Hello, world!");`
* Лямбда-выражение с одним параметром:

`x -> x * x;`
* Лямбда-выражение с несколькими параметрами:

`(x, y) -> x + y;`

* Лямбда-выражение с блоком кода в теле:

```java
(x, y) -> {
    int sum = x + y;
    System.out.println("Sum: " + sum);
};
```

###  3. Замыкание. К каким переменным есть доступ у лямбда-выражения?

Замыкание (closure) в контексте лямбда-выражений означает, что лямбда-выражение может захватывать переменные из своей
окружающей области видимости. Это означает, что лямбда-выражение имеет доступ к этим переменным, даже если они объявлены
вне самого выражения.

В Java, лямбда-выражения могут захватывать следующие типы переменных:
- Переменные экземпляра (instance variables): Лямбда-выражения имеют доступ к переменным экземпляра класса, в котором 
они определены. Это включает поля класса и нестатические переменные методов.
- Локальные переменные, объявленные как final или эффективно финальные (effectively final): Лямбда-выражения могут 
использовать значения локальных переменных, которые объявлены как final или не изменяются после инициализации. В Java 8 
и более поздних версиях не требуется явное объявление переменной как final, если она фактически является финальной (т.е.
не изменяется после инициализации).
- Локальные переменные, захваченные лямбда-выражением, должны быть эффективно финальными или фактически финальными. Это 
означает, что значения этих переменных не могут быть изменены внутри лямбда-выражения.

Пример использования замыкания с лямбда-выражением:

```java
public class Main {
    public static void main(String[] args) {
        int x = 10; // локальная переменная
        
        // Лямбда-выражение с захватом переменной x
        MyInterface myInterface = () -> System.out.println(x);
        
        myInterface.doSomething(); // Выводит: 10
    }
    
    interface MyInterface {
        void doSomething();
    }
}
```
В этом примере переменная x является локальной переменной в методе `main()`, но лямбда-выражение 
`() -> System.out.println(x)` может получить доступ к ней и использовать ее значение.

### 4. Ссылка на метод. Какие существуют ссылки на методы?

Ссылка на метод (method reference) в Java представляет собой сокращенную форму записи для вызова метода или создания 
объекта. Она позволяет передавать метод как аргумент или использовать его в функциональных интерфейсах.

Существуют несколько видов ссылок на методы в Java:
- Ссылка на статический метод (Static method reference):

`ClassName::staticMethodName`

Пример:
```java
Function<Integer, Integer> square = Math::square;
int result = square.apply(5); // Вызовет Math.square(5)
```
В этом примере мы передаем ссылку на статический метод square класса Math.

- Ссылка на метод экземпляра (Instance method reference):

`instance::instanceMethodName`

Пример:
```Java
List<String> names = new ArrayList<>();
Consumer<String> addName = names::add;
addName.accept("Alice"); // Вызовет names.add("Alice")
```
В этом примере мы передаем ссылку на метод add объекта names типа List<String>.

- Ссылка на метод экземпляра определенного объекта (Instance method reference of a particular object):

`ClassName::new`

Пример:

```Java
Supplier<List<String>> listSupplier = ArrayList::new;
List<String> names = listSupplier.get(); // Создаст новый объект ArrayList<String>()
```

В этом примере мы передаем ссылку на конструктор класса ArrayList.

Ссылки на методы позволяют упростить и сократить код, особенно при работе с функциональными интерфейсами и лямбда-выражениями.

### 5. Ссылка на конструктор. Как применяется?

Ссылка на конструктор (constructor reference) в Java позволяет создавать объекты с помощью ссылки на конструктор вместо 
явного вызова конструктора. Это удобный и краткий способ создания экземпляров классов, особенно при использовании 
функциональных интерфейсов и лямбда-выражений.

Ссылка на конструктор имеет следующий синтаксис:

`ClassName::new`

где ClassName - имя класса, для которого ссылка на конструктор создается.

Пример использования ссылки на конструктор:

```Java
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) {
        Supplier<MyClass> supplier = MyClass::new;
        MyClass instance = supplier.get(); // Создание экземпляра MyClass
    }
}

class MyClass {
    public MyClass() {
        // Конструктор класса
    }
}
```

В этом примере мы создаем ссылку на конструктор класса `MyClass` с помощью `MyClass::new`. Затем мы используем 
функциональный интерфейс `Supplier` для создания поставщика (supplier), который возвращает экземпляры класса MyClass с 
помощью метода `get()`.

Ссылка на конструктор также может быть использована с аргументами, если конструктор принимает параметры:

```Java
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<String, MyClass> function = MyClass::new;
        MyClass instance = function.apply("Hello"); // Создание экземпляра MyClass с аргументом "Hello"
    }
}

class MyClass {
    public MyClass(String message) {
        // Конструктор класса с аргументом
        System.out.println(message);
    }
}
```

В этом примере мы создаем ссылку на конструктор класса `MyClass`, принимающий строковый аргумент. Мы используем 
функциональный интерфейс `Function` для создания функции, которая принимает строку и возвращает экземпляр класса 
`MyClass` с помощью метода `apply()`.

Ссылки на конструкторы позволяют сделать код более компактным и выразительным при создании объектов.

### 6. Интерфейс Function. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?

Интерфейс Function<T, R> является функциональным интерфейсом в Java из пакета `java.util.function`. Его назначение состоит
в том, чтобы представлять операцию, которая принимает аргумент типа T и возвращает результат типа R.

Интерфейс Function<T, R> имеет следующую сигнатуру:

```java
interface Function<T, R> {
    R apply(T t);
    // ...
}
```

Метод `apply()` интерфейса Function принимает аргумент типа T и возвращает результат типа R.

Интерфейс Function близок по смыслу к другим функциональным интерфейсам из пакета `java.util.function`, таким как:

- Supplier<R>: Представляет операцию, которая не принимает аргументов, но возвращает значение типа R.
- Consumer<T>: Представляет операцию, которая принимает аргумент типа T и не возвращает результат.
- Predicate<T>: Представляет операцию, которая принимает аргумент типа T и возвращает булево значение (true/false).

Благодаря использованию этих функциональных интерфейсов в Java, код становится более гибким, читаемым и позволяет передавать операции в виде лямбда-выражений или методов.

Примеры использования интерфейса Function:

```java
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        // Преобразование строки в целое число
        Function<String, Integer> stringToInt = Integer::parseInt;
        int number = stringToInt.apply("42"); // Возвращает: 42

        // Преобразование целого числа в строку
        Function<Integer, String> intToString = String::valueOf;
        String text = intToString.apply(123); // Возвращает: "123"
    }
}
```

В этом примере мы используем интерфейс Function для преобразования строки в целое число и целого числа в строку с 
помощью ссылок на статические методы `Integer.parseInt()` и `String.valueOf()` соответственно.


### 7. Интерфейс UnaryOperator. Его назначение. Сравнить с интерфейсом Function

Интерфейс UnaryOperator<T> также является функциональным интерфейсом из пакета `java.util.function`. Его назначение 
состоит в том, чтобы представлять операцию, которая принимает аргумент типа T и возвращает результат того же типа T.

Интерфейс UnaryOperator<T> является подтипом интерфейса Function<T, T>, что означает, что он наследует метод `apply()`, 
который принимает аргумент типа T и возвращает результат типа T.

Сравнение интерфейсов UnaryOperator<T> и Function<T, R> заключается в следующем:

- Аргументы и результаты: В интерфейсе UnaryOperator<T> и аргумент, и результат имеют один и тот же тип T, тогда как в 
интерфейсе Function<T, R> аргумент и результат могут иметь разные типы T и R.
- Тип преобразования: Интерфейс UnaryOperator<T> представляет унарную операцию, которая выполняет преобразование над 
одним значением типа T и возвращает результат того же типа T. В то же время интерфейс Function<T, R> может 
представлять операцию, которая принимает значение типа T и возвращает результат типа R, что позволяет более гибко 
работать с различными типами входных и выходных данных.

Примеры использования интерфейса UnaryOperator:

```java
import java.util.function.UnaryOperator;

public class Main {
    public static void main(String[] args) {
        // Увеличение числа на 1
        UnaryOperator<Integer> increment = x -> x + 1;
        int result = increment.apply(5); // Возвращает: 6

        // Преобразование строки в верхний регистр
        UnaryOperator<String> uppercase = String::toUpperCase;
        String text = uppercase.apply("hello"); // Возвращает: "HELLO"
    }
}
```

В этом примере мы используем интерфейс UnaryOperator для увеличения числа на 1 с помощью лямбда-выражения и для 
преобразования строки в верхний регистр с помощью ссылки на метод `toUpperCase()`.

### 8. Интерфейс Supplier. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?

Интерфейс Supplier<T> является функциональным интерфейсом из пакета `java.util.function`. Его назначение состоит в том, 
чтобы представлять операцию, которая не принимает аргументов и возвращает результат типа T.

Интерфейс Supplier<T> имеет следующую сигнатуру:

```java
interface Supplier<T> {
    T get();
    // ...
}
```

Метод `get()` интерфейса Supplier не принимает аргументов и возвращает результат типа T.

Интерфейс Supplier близок по смыслу к другим функциональным интерфейсам из пакета `java.util.function`, таким как:

- Function<T, R>: Представляет операцию, которая принимает аргумент типа T и возвращает результат типа R.
- Consumer<T>: Представляет операцию, которая принимает аргумент типа T и не возвращает результат.
- UnaryOperator<T>: Представляет операцию, которая принимает аргумент типа T и возвращает результат того же типа T.

Эти интерфейсы позволяют описывать различные виды операций в функциональном стиле программирования, в котором операции 
могут передаваться в виде аргументов или применяться к данным в цепочке операций.

Пример использования интерфейса Supplier:

```java
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) {
        // Получение случайного числа
        Supplier<Double> randomValue = Math::random;
        double value = randomValue.get(); // Возвращает случайное число

        // Получение текущего времени
        Supplier<Long> currentTime = System::currentTimeMillis;
        long time = currentTime.get(); // Возвращает текущее время в миллисекундах
    }
}
```

В этом примере мы используем интерфейс Supplier для получения случайного числа с помощью ссылки на статический метод 
`Math.random()` и для получения текущего времени с помощью ссылки на статический метод `System.currentTimeMillis()`.

### 9. Интерфейс Predicate. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?

Интерфейс Predicate<T> является функциональным интерфейсом из пакета `java.util.function`. Его назначение состоит в том, 
чтобы представлять операцию, которая принимает аргумент типа T и возвращает булево значение (true/false), в зависимости 
от выполнения определенного условия.

Интерфейс Predicate<T> имеет следующую сигнатуру:

```java
interface Predicate<T> {
    boolean test(T t);
    // ...
}
```

Метод `test()` интерфейса Predicate принимает аргумент типа T и возвращает булево значение.

Интерфейс Predicate близок по смыслу к другим функциональным интерфейсам из пакета `java.util.function`, таким как:

- Function<T, R>: Представляет операцию, которая принимает аргумент типа T и возвращает результат типа R.
- Consumer<T>: Представляет операцию, которая принимает аргумент типа T и не возвращает результат.
- Supplier<T>: Представляет операцию, которая не принимает аргументов, но возвращает результат типа T.

Все эти функциональные интерфейсы связаны с операциями над значениями, но отличаются входными и выходными параметрами:

* Function принимает аргумент и возвращает результат.
* Consumer принимает аргумент, но не возвращает результат.
* Supplier не принимает аргументов, но возвращает результат.
* Predicate принимает аргумент и возвращает булево значение.

Интерфейс Predicate полезен, когда требуется выполнение условия или проверка предиката для фильтрации или выборки 
элементов из коллекции, проведения проверок на соответствие определенным условиям и т.д.

Примеры использования интерфейса Predicate:

```java
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        // Проверка на четность числа
        Predicate<Integer> isEven = n -> n % 2 == 0;
        boolean result1 = isEven.test(4); // Возвращает: true
        boolean result2 = isEven.test(7); // Возвращает: false

        // Проверка на пустоту строки
        Predicate<String> isEmpty = s -> s.isEmpty();
        boolean result3 = isEmpty.test(""); // Возвращает: true
        boolean result4 = isEmpty.test("Hello"); // Возвращает: false
    }
}
```

В этом примере мы используем интерфейс Predicate для проверки числа на четность с помощью лямбда-выражения и для 
проверки строки на пустоту с помощью лямбда-выражения.

### 10. Интерфейс Consumer. Его назначение. Какие существуют близкие по смыслу интерфейсы и почему можно сделать такой вывод?

Интерфейс Consumer<T> является функциональным интерфейсом из пакета `java.util.function`. Его назначение состоит в том, 
чтобы представлять операцию, которая принимает аргумент типа T, но не возвращает результат. Он обычно используется для 
выполнения некоторых действий или операций над объектами типа T.

Интерфейс Consumer<T> имеет следующую сигнатуру:

```java
interface Consumer<T> {
    void accept(T t);
    // ...
}
```

Метод `accept()` интерфейса Consumer принимает аргумент типа T и не возвращает результат.

Интерфейс Consumer близок по смыслу к другим функциональным интерфейсам из пакета `java.util.function`, таким как:

- Function<T, R>: Представляет операцию, которая принимает аргумент типа T и возвращает результат типа R.
- Predicate<T>: Представляет операцию, которая принимает аргумент типа T и возвращает булево значение.

Все эти функциональные интерфейсы связаны с операциями над значениями, но отличаются входными и выходными параметрами:

* Function принимает аргумент и возвращает результат.
* Consumer принимает аргумент, но не возвращает результат.
* Predicate принимает аргумент и возвращает булево значение.

Интерфейс Consumer полезен, когда требуется выполнение операций над объектами типа T, таких как вывод на экран, 
изменение состояния объекта, запись в файл и т.д.

Примеры использования интерфейса Consumer:

```java
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        // Вывод строки на экран
        Consumer<String> printString = s -> System.out.println(s);
        printString.accept("Hello, world!");

        // Изменение состояния объекта
        Person person = new Person();
        Consumer<Person> updatePerson = p -> {
            p.setName("John");
            p.setAge(30);
        };
        updatePerson.accept(person);

        // Запись в файл
        FileWriter writer = new FileWriter("output.txt");
        Consumer<String> writeToFile = line -> {
            try {
                writer.write(line);
                writer.write("\n");
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
        writeToFile.accept("This is a line of text");
        writer.close();
    }
}

class Person {
    private String name;
    private int age;

    // Геттеры и сеттеры...

    // ...
}
```

В этом примере мы используем интерфейс Consumer для вывода строки на экран с помощью лямбда-выражения, для изменения 
состояния объекта Person с помощью лямбда-выражения и для записи текста в файл с помощью лямбда-выражения.

### 11. Интерфейс Comparator. Его назначение

Интерфейс Comparator<T> является интерфейсом из пакета `java.util`. Его назначение состоит в том, чтобы предоставить 
способ сравнения двух объектов типа T. Он используется для установления порядка сортировки объектов или для определения 
отношений "больше", "меньше" или "равно" между объектами.

Интерфейс Comparator<T> имеет следующую сигнатуру:

```java
interface Comparator<T> {
    int compare(T o1, T o2);
    // ...
}
```

Метод `compare()` интерфейса Comparator принимает два аргумента типа T и возвращает целочисленное значение:

- Если `compare()` возвращает отрицательное число, это означает, что `o1` меньше `o2`.
- Если `compare()` возвращает положительное число, это означает, что `o1` больше `o2`.
- Если `compare()` возвращает ноль, это означает, что `s` равно `o2`.

Интерфейс Comparator используется вместе с методами сортировки и структурами данных, которые требуют упорядочения 
элементов, такими как сортировка списка, деревья и т.д. Он позволяет определить пользовательский порядок сортировки, 
отличный от естественного порядка элементов.

Пример использования интерфейса Comparator:

```java
import java.util.Comparator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");
        names.add("Dave");

        // Сортировка по алфавиту в обратном порядке
        Comparator<String> reverseComparator = (s1, s2) -> s2.compareTo(s1);
        Collections.sort(names, reverseComparator);

        // Вывод отсортированного списка
        for (String name : names) {
            System.out.println(name);
        }
    }
}
```

В этом примере мы используем интерфейс Comparator для создания компаратора `reverseComparator`, который сравнивает строки 
в обратном порядке. Затем мы используем этот компаратор для сортировки списка `names` с помощью метода `Collections.sort()`.
В результате, имена будут отсортированы в обратном алфавитном порядке.

### 12. Как создать собственный функциональный интерфейс?

Для создания собственного функционального интерфейса в Java, нужно выполнить следующие шаги:

- Определите интерфейс с единственным абстрактным методом.
- Добавьте аннотацию `@FunctionalInterface` перед объявлением интерфейса (это необязательно, но рекомендуется, чтобы 
указать, что интерфейс является функциональным).

Вот пример создания собственного функционального интерфейса:

```java
@FunctionalInterface
interface MyFunctionalInterface {
    void doSomething();
}
```

В этом примере `MyFunctionalInterface` является собственным функциональным интерфейсом с единственным абстрактным методом 
`doSomething()`, который не принимает аргументов и не возвращает результат.

Теперь вы можете использовать этот собственный функциональный интерфейс для передачи лямбда-выражений или методов в 
качестве аргументов или присваивать им значения. Например:

```java
public class Main {
    public static void main(String[] args) {
        MyFunctionalInterface myFunction = () -> System.out.println("Doing something");
        myFunction.doSomething();
    }
}
```

В этом примере мы создали экземпляр нашего собственного функционального интерфейса `MyFunctionalInterface` с помощью 
лямбда-выражения, которое выводит строку "Doing something". Затем мы вызываем метод `doSomething()` у этого экземпляра и 
видим вывод строки.

Обратите внимание, что использование аннотации `@FunctionalInterface` не является обязательным, но рекомендуется для 
явного указания намерений интерфейса быть функциональным.

Таким образом, вы можете создавать собственные функциональные интерфейсы, определяя интерфейс с единственным абстрактным
методом, чтобы легко передавать логику в виде лямбда-выражений или методов в Java.

### 13. Как сортировать список с применением лямбда-выражений?

Для сортировки списка с применением лямбда-выражений в Java, вы можете использовать метод `sort()` из класса `Collections` 
или метод `sort()` из класса `List`. Вот примеры обоих подходов:

- Использование метода `sort()` из класса `Collections`:

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");
        names.add("Dave");

        // Сортировка списка по алфавиту
        Collections.sort(names, (s1, s2) -> s1.compareTo(s2));

        // Вывод отсортированного списка
        for (String name : names) {
            System.out.println(name);
        }
    }
}
```

В этом примере мы используем метод `sort()` из класса `Collections` для сортировки списка `names`. Мы передаем 
лямбда-выражение `(s1, s2) -> s1.compareTo(s2)` в качестве аргумента, которое сравнивает две строки `s1` и `s2`.
Результатом сравнения является алфавитный порядок.

- Использование метода `sort()` из класса `List`:

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");
        names.add("Dave");

        // Сортировка списка по алфавиту
        names.sort((s1, s2) -> s1.compareTo(s2));

        // Вывод отсортированного списка
        for (String name : names) {
            System.out.println(name);
        }
    }
}
```

В этом примере мы используем метод `sort()` непосредственно у объекта списка names. Мы также передаем лямбда-выражение 
`(s1, s2) -> s1.compareTo(s2)` в качестве аргумента для сравнения строк.

Оба этих подхода приведут к отсортированному списку names в алфавитном порядке.

Таким образом, вы можете использовать лямбда-выражения для определения пользовательской логики сравнения элементов и 
применять ее при сортировке списка в Java.

### 14. Можно ли называть интерфейс функциональным, если при его объявлении не была применена аннотация @FunctionalInterface?

Да, в Java интерфейс можно считать функциональным, даже если при его объявлении не была применена аннотация 
`@FunctionalInterface`. Аннотация @FunctionalInterface является просто соглашением и служит для явного указания того, 
что интерфейс предназначен для использования как функциональный интерфейс.

Важное свойство функциональных интерфейсов состоит в том, что они имеют только один абстрактный метод (за исключением 
методов из класса `Object`, таких как `equals()`, `hashCode()`, `toString()`, которые являются методами по умолчанию). 
Если интерфейс удовлетворяет этому условию, то он может быть использован в контексте функциональных интерфейсов, и его 
можно рассматривать как функциональный интерфейс.

Однако применение аннотации @FunctionalInterface имеет следующие преимущества:

- Помогает разработчикам понять, что интерфейс предназначен для использования как функциональный интерфейс.
- При нарушении условия функционального интерфейса (например, добавлении еще одного абстрактного метода) компилятор 
- выдаст ошибку, если аннотация `@FunctionalInterface` была применена.

Таким образом, хотя аннотация `@FunctionalInterface` не является обязательной для функциональных интерфейсов, ее 
применение помогает ясно указать намерение использования интерфейса как функционального.

## Задания к главе:
1. С помощью каррирования реализовать функцию сложения двух чисел, функцию проверки строки на регулярное выражение,
   функцию разбиения строки по регулярному выражению.
- [x] Решение задачи.
2. Определить, являются ли слова анаграммами, т.е. можно ли из одного слова составить другое перестановкой букв.
- [x] Решение задачи.
3. Написать класс Пользователь с полями: id, имя, возраст, страна. Создать массив Пользователей. Отсортировать по стране
   и возрасту. Выбрать всех Пользователей старше заданного возраста, первая буква имени у которых начинается с заданной
   буквы. Получить максимальный и минимальный элемент в сгруппированном результате по возрасту.
- [x] Решение задачи.
4. Написать функциональный интерфейс с методом, который принимает число и возвращает булево значение. Написать
   реализацию такого интерфейса в виде лямбда-выражения, которое возвращает true, если переданное число делится
   без остатка на 31.
- [x] Решение задачи.
5. Написать функциональный интерфейс с методом, который принимает две строки и возвращает тоже строку. Написать
   реализацию такого интерфейса в виде лямбды, которая возвращает ту строку, которая длиннее.
- [x] Решение задачи.
6. Написать функциональный интерфейс с методом, который принимает три дробных числа: a, b, c и возвращает тоже дробное
   число. Написать реализацию такого интерфейса в виде лямбда-выражения, которое возвращает дискриминант.
- [x] Решение задачи.
7. Написать класс Студент с полями имя, возраст. Создать массив Студентов. Выполнить сортировку по оценке выше 8 баллов
   и сортировать результат по имени.
- [x] Решение задачи.
8. Вывести количество вхождений заданного слова в тексте соответственно из файла в виде \[слово1-2, слово2-3, слово3-0].
- [x] Решение задачи.
9. Вывести коллекцию количества вхождений символа в тексте соответственно из файла.
- [x] Решение задачи.
10. Дано три разных целых числа. Реализовать лямбда-выражение, которое находит наибольшее из этих трех чисел.
- [x] Решение задачи.
11. С помощью лямбда-выражений создать метод, который на вход принимает строку, количество копий N, ограничение на общую
    длину L. Поставить запятые после каждого слова, сделать N копий, и если слов больше M — не выводить остальные слова.
- [x] Решение задачи.
12. Создать массив целых чисел. Убрать все четные элементы из массива и заполнить в конце нулями до прежнего размера массива.
- [x] Решение задачи.
13. Создать массив целых чисел. Используя лямбда-выражение, отсортировать массив по убыванию.
- [x] Решение задачи.
14. Определить, является ли число элементом Фибоначчи с помощью лямбда-выражений.
- [x] Решение задачи.
15. Создать N пар значений x, y, которые представляют координаты точки на плоскости. Выстроить все точки по увеличению
    их удаленности от начала координат, и вывести отсортированный список точек на экран в формате: (X:Y).
- [x] Решение задачи.
16. Написать функцию, которая вычисляет сумму списка аргументов произвольной длины с разными типами элементов массива.
- [x] Решение задачи.
17. С помощью лямбда-выражений определить, можно ли из длин сторон a, b, c образовать треугольник?
- [x] Решение задачи.
18. Продемонстрировать работу лямбда-выражения, которое получает входным параметром целое число x и вычисляет количество
    вхождений заданной цифры в этом числе.
- [x] Решение задачи.
19. Дан предикат condition и две функции ifTrue и ifFalse. Написать метод ternaryOperator, который из них построит
    новую функцию, возвращающую значение функции ifTrue, если предикат выполнен, и значение ifFalse иначе.
- [x] Решение задачи.
20. С помощью лямбда-выражений вычислить факториал заданного числа.
- [x] Решение задачи.
21. Дан прямоугольный треугольник с катетами a и b. С помощью лямбда-выражения найти радиус вписанной в треугольник окружности.
- [x] Решение задачи.
22. Дана строка. Вернуть строку, где сначала идут гласные, а потом согласные из заданной строки. Гласные и согласные
    должны быть в отсортированном порядке.
- [x] Решение задачи.
23. Написать программу, которая выводит число прописью.
- [ ] Решение задачи.
24. Вывести массив NxN, заполненный по спирали в порядке возрастания.
- [ ] Решение задачи и Unit тесты.
25. Определить, является ли строка панграммой (использует каждую букву алфавита хотя бы один раз).
- [x] Решение задачи и Unit тесты.
26. С помощью генераторов вывести первые N простых чисел.
- [x] Решение задачи и Unit тесты.
27. Преобразовать каждый элемент списка, цену без добавленной стоимости в цену с добавленной стоимостью.
- [x] Решение задачи и Unit тесты.
28. Дано время в 12-часовом формате в виде строки. Конвертировать время в 24-часовой формат.
- [x] Решение задачи и Unit тесты.
29. Дан массив чисел. Построить из этих чисел двоичное дерево поиска и найти глубину этого дерева.
- [ ] Решение задачи и Unit тесты.
30. Последовательность координат вершин многоугольника задана массивом чисел. Определить, лежит ли точка внутри многоугольника.
- [x] Решение задачи и Unit тесты.
31. С применением лямбда-выражения перевернуть входную строку.
- [x] Решение задачи и Unit тесты.
32. С помощью лямбда-выражений разработать метод, который на вход получает массив объектов, а возвращает его уже без дубликатов.
- [x] Решение задачи и Unit тесты.
33. Написать предикат, выбирающий имена, которые начинаются с заданной буквы.
- [x] Решение задачи и Unit тесты.
34. Написать программу, возвращающую значения числа Пи, используя лямбда-выражения.
- [x] Решение задачи и Unit тесты.
35. Используя фильтр, создать новый массив из строк с числом символов больше заданного.
- [x] Решение задачи и Unit тесты.
- [ ] Доработать работу с пустыми массивами.
36. В массиве строк найти все строки, начинающиеся на заданный символ и состоящие из N букв.
- [x] Решение задачи и Unit тесты.
- [ ] Доработать работу с пустыми массивами.